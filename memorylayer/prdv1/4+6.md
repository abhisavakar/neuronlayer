# Gateway Pattern Implementation Plan

## Overview

Refactor MemoryLayer from **51 MCP tools** to **4 gateway tools + 6 standalone** (10 total), saving ~5,000 tokens per API call on tool description overhead.

**Benchmark Context:** 759x speedup, 51.7% token reduction, p < 0.001, Cohen's d = 3.46

---

## The 4 Gateway Tools

### 1. `memory_query` - "What do I need to know?"
**Routes to:** get_context, search_codebase, get_file_context, get_file_summary, get_symbol, get_dependencies, get_predicted_files, get_confidence, list_sources, suggest_existing

### 2. `memory_record` - "Remember this"
**Routes to:** record_decision, record_decision_with_author, learn_pattern, mark_context_useful, set_feature_context, mark_critical, add_pattern_example

### 3. `memory_review` - "Check this code"
**Routes to:** validate_pattern, check_conflicts, suggest_existing, check_tests, get_confidence, find_similar_bugs, suggest_test_update, get_related_tests, get_test_coverage

### 4. `memory_status` - "What's the state?"
**Routes to:** get_project_summary, what_happened, what_changed, get_architecture, get_changelog, validate_docs, get_context_health, list_patterns, get_architecture_stats, find_undocumented, get_critical_context, get_learning_stats

---

## 6 Standalone Tools (Require Explicit IDs/Actions)

1. `switch_project` - Changes global project context
2. `switch_feature_context` - Changes feature tracking
3. `trigger_compaction` - Destructive operation
4. `update_decision_status` - Requires decision ID
5. `export_decisions_to_adr` - File system write
6. `discover_projects` - System-wide discovery

---

## Files to Create

### `src/server/gateways/types.ts`
```typescript
// Input/output types for all 4 gateways
export interface MemoryQueryInput {
  query: string;
  file?: string;
  symbol?: string;
  code?: string;
  max_results?: number;
  include_confidence?: boolean;
  action?: 'context' | 'search' | 'file' | 'summary' | 'symbol' |
           'dependencies' | 'predict' | 'confidence' | 'sources' | 'existing';
}

export interface MemoryRecordInput {
  content: string;
  title?: string;
  code?: string;
  pattern_name?: string;
  files?: string[];
  tags?: string[];
  author?: string;
  type?: 'decision' | 'pattern' | 'feedback' | 'feature' | 'critical';
  action?: 'decision' | 'pattern' | 'feedback' | 'feature' | 'critical';
}

export interface MemoryReviewInput {
  code: string;
  file?: string;
  intent?: string;
  include_tests?: boolean;
  include_patterns?: boolean;
  action?: 'pattern' | 'conflicts' | 'tests' | 'confidence' | 'bugs' | 'coverage';
}

export interface MemoryStatusInput {
  scope?: 'project' | 'architecture' | 'changes' | 'docs' | 'health' | 'patterns' | 'all';
  since?: string;
  file?: string;
  action?: 'summary' | 'happened' | 'changed' | 'architecture' | 'changelog' |
           'health' | 'patterns' | 'stats' | 'undocumented' | 'critical';
}
```

### `src/server/gateways/router.ts`
- Intent detection (file paths, symbols, code blocks)
- Query parsing utilities
- Action routing logic for each gateway

### `src/server/gateways/aggregator.ts`
- Result deduplication across searches
- Risk score calculation for reviews
- Response merging utilities

### `src/server/gateways/memory-query.ts`
```typescript
export async function handleMemoryQuery(
  engine: MemoryLayerEngine,
  input: MemoryQueryInput
): Promise<MemoryQueryResponse> {
  // If explicit action, route directly
  if (input.action) {
    return routeToAction(engine, input.action, input);
  }

  // Auto-detect: file path → get_file_context
  // Auto-detect: symbol → get_symbol + dependencies
  // Auto-detect: code → confidence + sources + existing
  // Default: get_context + search_codebase (merged)

  const results = await Promise.all([
    engine.getContext(input.query, input.file),
    engine.searchCodebase(input.query, input.max_results || 10)
  ]);

  return aggregateQueryResults(results, input);
}
```

### `src/server/gateways/memory-record.ts`
```typescript
export async function handleMemoryRecord(
  engine: MemoryLayerEngine,
  input: MemoryRecordInput
): Promise<MemoryRecordResponse> {
  // Auto-detect type from input
  const recordType = input.type || detectRecordType(input);

  // For decisions, pre-check conflicts
  if (recordType === 'decision') {
    const conflicts = await engine.checkCodeConflicts(input.content);
    // Include warning in response if conflicts found
  }

  // Route to appropriate recording method
  switch (recordType) {
    case 'decision':
      return engine.recordDecision(input.title!, input.content, input.files, input.tags);
    case 'pattern':
      return engine.learnPattern(input.code!, input.pattern_name!, input.content);
    // ... etc
  }
}
```

### `src/server/gateways/memory-review.ts`
```typescript
export async function handleMemoryReview(
  engine: MemoryLayerEngine,
  input: MemoryReviewInput
): Promise<MemoryReviewResponse> {
  // Run all checks in parallel
  const [patternResult, conflicts, confidence, existing] = await Promise.all([
    engine.validatePattern(input.code),
    engine.checkCodeConflicts(input.code),
    engine.getConfidence(input.code, input.intent),
    engine.suggestExisting(input.intent || input.code.slice(0, 100))
  ]);

  // If file provided, also check tests
  let testResult = null;
  if (input.file && input.include_tests !== false) {
    testResult = engine.checkTests(input.code, input.file);
  }

  // Calculate unified risk score
  const riskScore = calculateRiskScore(patternResult, conflicts, testResult, confidence);

  return {
    verdict: riskScore > 70 ? 'reject' : riskScore > 30 ? 'warning' : 'approve',
    risk_score: riskScore,
    patterns: patternResult,
    conflicts: conflicts.conflicts,
    existing_alternatives: existing,
    test_impact: testResult,
    confidence: confidence.confidence
  };
}
```

### `src/server/gateways/memory-status.ts`
```typescript
export async function handleMemoryStatus(
  engine: MemoryLayerEngine,
  input: MemoryStatusInput
): Promise<MemoryStatusResponse> {
  const scope = input.scope || 'project';

  // Gather relevant status based on scope
  const summary = engine.getProjectSummary();

  if (scope === 'all' || scope === 'changes') {
    const changes = engine.whatChanged({ since: input.since || 'this week' });
  }

  if (scope === 'all' || scope === 'architecture') {
    const arch = await engine.getArchitecture();
  }

  // ... aggregate based on scope
}
```

### `src/server/gateways/index.ts`
```typescript
export const gatewayDefinitions: ToolDefinition[] = [
  {
    name: 'memory_query',
    description: 'Search project memory — code, decisions, patterns, history. Returns semantically ranked results with confidence scores. 759x faster than grep, 50% fewer tokens than raw context.',
    inputSchema: { /* MemoryQueryInput schema */ }
  },
  {
    name: 'memory_record',
    description: 'Record decisions, patterns, or learnings into persistent memory. Auto-detects type. Checks conflicts before saving.',
    inputSchema: { /* MemoryRecordInput schema */ }
  },
  {
    name: 'memory_review',
    description: 'Review code against project patterns, decisions, past bugs, and test coverage. Returns violations, suggestions, and risk score.',
    inputSchema: { /* MemoryReviewInput schema */ }
  },
  {
    name: 'memory_status',
    description: 'Project overview — structure, recent changes, architecture, health. Use at session start.',
    inputSchema: { /* MemoryStatusInput schema */ }
  }
];

export const standaloneDefinitions: ToolDefinition[] = [
  // 6 tools that need explicit IDs/actions
];

export async function handleGatewayCall(
  engine: MemoryLayerEngine,
  gatewayName: string,
  args: Record<string, unknown>
): Promise<unknown> {
  switch (gatewayName) {
    case 'memory_query':
      return handleMemoryQuery(engine, args as MemoryQueryInput);
    case 'memory_record':
      return handleMemoryRecord(engine, args as MemoryRecordInput);
    case 'memory_review':
      return handleMemoryReview(engine, args as MemoryReviewInput);
    case 'memory_status':
      return handleMemoryStatus(engine, args as MemoryStatusInput);
    default:
      throw new Error(`Unknown gateway: ${gatewayName}`);
  }
}
```

---

## Files to Modify

### `src/server/mcp.ts` (lines 37-47)
```typescript
import { gatewayDefinitions, standaloneDefinitions, handleGatewayCall } from './gateways/index.js';
import { handleToolCall } from './tools.js';

// In setupHandlers():
this.server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [...gatewayDefinitions, ...standaloneDefinitions].map(t => ({
      name: t.name,
      description: t.description,
      inputSchema: t.inputSchema
    }))
  };
});

this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    let result;

    // Check if it's a gateway
    if (['memory_query', 'memory_record', 'memory_review', 'memory_status'].includes(name)) {
      result = await handleGatewayCall(this.engine, name, args || {});
    } else {
      // Standalone tools route to existing handler
      result = await handleToolCall(this.engine, name, args || {});
    }

    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  } catch (error) {
    // ... existing error handling
  }
});
```

### `src/server/tools.ts`
- Keep entire file unchanged (internal use by gateways)
- Existing `handleToolCall` continues to work for standalone tools
- Gateways call engine methods directly (not through handleToolCall)

---

## Implementation Order

1. **Create `src/server/gateways/types.ts`** - All input/output types
2. **Create `src/server/gateways/router.ts`** - Intent detection
3. **Create `src/server/gateways/aggregator.ts`** - Result merging
4. **Create `src/server/gateways/memory-query.ts`** - Query gateway
5. **Create `src/server/gateways/memory-record.ts`** - Record gateway
6. **Create `src/server/gateways/memory-review.ts`** - Review gateway
7. **Create `src/server/gateways/memory-status.ts`** - Status gateway
8. **Create `src/server/gateways/index.ts`** - Exports and definitions
9. **Modify `src/server/mcp.ts`** - Register gateways
10. **Test all 4 gateways** - Manual + automated

---

## Verification

### Build Verification
```bash
npm run build
npx tsc --noEmit
```

### Test with Claude Desktop
1. Update claude_desktop_config.json to use local build
2. Test each gateway:
   - `memory_query`: "How does authentication work?"
   - `memory_record`: Record a test decision
   - `memory_review`: Review a code snippet
   - `memory_status`: Get project overview

### Existing Tool Compatibility
- Standalone tools still work via `handleToolCall`
- All 51 original tools remain functional internally
- Gateway responses include `sources_used` array showing internal routing

---

## Token Savings Math

| Metric | Before (51 tools) | After (10 tools) |
|--------|-------------------|------------------|
| Tool descriptions | ~5,500 tokens | ~600 tokens |
| Avg calls per task | 5-10 | 1-2 |
| Total per task | 2,500-5,000 | 600-1,200 |
| **Savings** | — | **~80% reduction** |

Combined with 51.7% retrieval reduction = **~90% total token reduction** per task.
claude --resume dcf08d1e-2672-422e-85b2-4258fb295f77