import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import type { Decision } from '../types/index.js';

export interface ADRExportOptions {
  outputDir?: string;
  format?: 'madr' | 'nygard' | 'simple';
  includeIndex?: boolean;
}

export class ADRExporter {
  private projectPath: string;

  constructor(projectPath: string) {
    this.projectPath = projectPath;
  }

  // Export a single decision to ADR file
  exportDecision(decision: Decision, options: ADRExportOptions = {}): string {
    const outputDir = options.outputDir || join(this.projectPath, 'docs', 'decisions');
    const format = options.format || 'madr';

    // Ensure output directory exists
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    // Generate filename
    const existingFiles = this.getExistingADRFiles(outputDir);
    const nextNumber = this.getNextADRNumber(existingFiles);
    const slug = this.slugify(decision.title);
    const filename = `${String(nextNumber).padStart(4, '0')}-${slug}.md`;
    const filePath = join(outputDir, filename);

    // Generate content based on format
    let content: string;
    switch (format) {
      case 'madr':
        content = this.formatMADR(decision, nextNumber);
        break;
      case 'nygard':
        content = this.formatNygard(decision, nextNumber);
        break;
      case 'simple':
      default:
        content = this.formatSimple(decision, nextNumber);
        break;
    }

    // Write file
    writeFileSync(filePath, content);

    return filePath;
  }

  // Export all decisions
  exportAllDecisions(decisions: Decision[], options: ADRExportOptions = {}): string[] {
    const exportedFiles: string[] = [];
    const outputDir = options.outputDir || join(this.projectPath, 'docs', 'decisions');

    // Sort by creation date
    const sorted = [...decisions].sort((a, b) =>
      a.createdAt.getTime() - b.createdAt.getTime()
    );

    for (const decision of sorted) {
      const filePath = this.exportDecision(decision, { ...options, outputDir });
      exportedFiles.push(filePath);
    }

    // Generate index if requested
    if (options.includeIndex !== false) {
      const indexPath = this.generateIndex(decisions, outputDir);
      exportedFiles.push(indexPath);
    }

    return exportedFiles;
  }

  // Generate index file
  private generateIndex(decisions: Decision[], outputDir: string): string {
    const indexPath = join(outputDir, 'README.md');

    const lines: string[] = [
      '# Architecture Decision Records',
      '',
      'This directory contains Architecture Decision Records (ADRs) for this project.',
      '',
      '## Decisions',
      '',
      '| # | Title | Status | Date |',
      '|---|-------|--------|------|'
    ];

    const sorted = [...decisions].sort((a, b) =>
      a.createdAt.getTime() - b.createdAt.getTime()
    );

    sorted.forEach((d, i) => {
      const num = String(i + 1).padStart(4, '0');
      const slug = this.slugify(d.title);
      const status = d.status || 'accepted';
      const date = d.createdAt.toISOString().split('T')[0];
      lines.push(`| ${num} | [${d.title}](./${num}-${slug}.md) | ${status} | ${date} |`);
    });

    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('*Generated by MemoryLayer*');

    writeFileSync(indexPath, lines.join('\n'));
    return indexPath;
  }

  // MADR format (Markdown Any Decision Records)
  private formatMADR(decision: Decision, number: number): string {
    const date = decision.createdAt.toISOString().split('T')[0];
    const status = decision.status || 'accepted';

    return `# ${decision.title}

* Status: ${status}
* Date: ${date}
${decision.author ? `* Author: ${decision.author}` : ''}
${decision.tags.length > 0 ? `* Tags: ${decision.tags.join(', ')}` : ''}

## Context and Problem Statement

${decision.description}

## Decision Drivers

* [List the main factors that influenced this decision]

## Considered Options

* [Option 1]
* [Option 2]
* [Option 3]

## Decision Outcome

Chosen option: "${decision.title}"

### Consequences

* Good, because [positive consequence]
* Bad, because [negative consequence]

${decision.files.length > 0 ? `## Related Files

${decision.files.map(f => `* \`${f}\``).join('\n')}
` : ''}
${decision.supersededBy ? `## Superseded By

This decision has been superseded by [ADR ${decision.supersededBy}](./${decision.supersededBy}.md).
` : ''}
---
*Exported from MemoryLayer*
`;
  }

  // Nygard format (original ADR format)
  private formatNygard(decision: Decision, number: number): string {
    const date = decision.createdAt.toISOString().split('T')[0];
    const status = decision.status || 'Accepted';

    return `# ${number}. ${decision.title}

Date: ${date}

## Status

${status.charAt(0).toUpperCase() + status.slice(1)}
${decision.supersededBy ? `\nSuperseded by [ADR ${decision.supersededBy}](./${decision.supersededBy}.md)` : ''}

## Context

${decision.description}

## Decision

We will ${decision.title.toLowerCase()}.

## Consequences

[Describe the consequences of this decision]

${decision.files.length > 0 ? `## Related Files

${decision.files.map(f => `- ${f}`).join('\n')}
` : ''}
---
*Exported from MemoryLayer*
`;
  }

  // Simple format
  private formatSimple(decision: Decision, number: number): string {
    const date = decision.createdAt.toISOString().split('T')[0];

    return `# ${decision.title}

**Date:** ${date}
${decision.author ? `**Author:** ${decision.author}` : ''}
**Status:** ${decision.status || 'accepted'}
${decision.tags.length > 0 ? `**Tags:** ${decision.tags.join(', ')}` : ''}

## Description

${decision.description}

${decision.files.length > 0 ? `## Related Files

${decision.files.map(f => `- \`${f}\``).join('\n')}
` : ''}
---
*Exported from MemoryLayer*
`;
  }

  private getExistingADRFiles(dir: string): string[] {
    if (!existsSync(dir)) return [];

    try {
      const { readdirSync } = require('fs');
      return readdirSync(dir)
        .filter((f: string) => /^\d{4}-.*\.md$/.test(f))
        .sort();
    } catch {
      return [];
    }
  }

  private getNextADRNumber(existingFiles: string[]): number {
    if (existingFiles.length === 0) return 1;

    const numbers = existingFiles
      .map(f => parseInt(f.split('-')[0] || '0', 10))
      .filter(n => !isNaN(n));

    return Math.max(...numbers, 0) + 1;
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .slice(0, 50);
  }
}
